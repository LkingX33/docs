---
title: Verifying log entries
description: >-
  Learn how to verify log entires on a different chain using CrossL2Inbox.
lang: en-US
content_type: tutorial
topic: verify-message
personas:
  - protocol-developer
  - chain-operator
  - app-developer
categories:
  - protocol
  - interoperability
  - cross-chain-messaging
  - message-relaying
  - superchain
is_imported_content: 'false'
---

import { Callout, Steps, Tabs } from 'nextra/components'
import { AutorelayCallout } from '@/components/AutorelayCallout'

# Verifying log entries

This guide shows how to verify log entries from a specific chain on a different chain in an interop cluster.
This lets you use interoperability with applications on a different chain that was never written with interoperability in mind.

To demonstrate this functionality, we'll use an [attestation](https://attest.org/) from one chain in another.

## Overview

<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  *   How to verify log messages from one blockchain on another.
  *   How to use the EAS SDK to attest for facts and add schemas from offchain code.

  **Technical knowledge**

  *   Intermediate JavaScript knowledge
  *   Understanding of smart contract development
  *   Familiarity with blockchain concepts

  **Development environment**

  *   Unix-like operating system (Linux, macOS, or WSL for Windows)
  *   Node.js version 16 or higher
  *   Git for version control

  **Required tools**

  The tutorial uses these primary tools:

  *   Node: For running TypeScript code from the command line
  *   Viem: For blockchain interaction
  *   Foundry: For smart contract development
</details>

### What you'll build

*   A JavaScript program to create an attestation and then verify it on a different chain.
*   A Solidity contract that can verify attestations onchain.

## Directions

<Steps>
  ### Preparation

  1.  If you are using Supersim, setup the [SuperchainERC20 starter kit](/app-developers/starter-kit#setup).
      The `pnpm dev` step also starts Supersim.

  2.  Store the configuration in environment variables.

        <Tabs items={['Supersim', 'Devnets']}>
          <Tabs.Tab>
            ```sh
            export PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
            URL_CHAIN_A=http://127.0.0.1:9545
            URL_CHAIN_B=http://127.0.0.1:9546
            export CHAIN_B_ID=`cast chain-id --rpc-url $URL_CHAIN_B`            
            ```
          </Tabs.Tab>

          <Tabs.Tab>
            1.  Set `PRIVATE_KEY` to the private key for an address that has ETH on the two devnets.

            2.  Run these commands to specify the rest of the environment variables.

            ```sh
            export PRIVATE_KEY
            URL_CHAIN_A=https://interop-alpha-0.optimism.io
            URL_CHAIN_B=https://interop-alpha-1.optimism.io
            export CHAIN_B_ID=`cast chain-id --rpc-url $URL_CHAIN_B`            
            ```
          </Tabs.Tab>
        </Tabs>

  ### Create an attestation

  There are already attestations in the production chains.
  However, that may not be the case in the devnets, and it is definitely not the case in the Supersim instance you just started.

  So the first step is to actually send an attestation to one of the chains.

  1.  Create a new JavaScript project.

      ```sh
      mkdir -p verify-messages/offchain
      cd verify-messages/offchain
      npm init -y
      npm install @eth-optimism/viem @ethereum-attestation-service/eas-sdk ethers viem
      ```

  2.  Create a file, `attest.mjs`.

      ```js file=<rootDir>/public/tutorials/attest.mjs hash=41df7a53bd4803473a57d464e614691c 
      ```

        <details>
          <summary>Explanation</summary>

          ```js file=<rootDir>/public/tutorials/attest.mjs#L23-L42 hash=afc5bb44d71c09c6853bf6bd0b7c9661 
          ```

          The [EAS SDK](https://docs.attest.org/docs/developer-tools/eas-sdk) we use for attestations uses [Ethers](https://docs.ethers.org/v6/) rather than [Viem](https://viem.sh/).
          This function lets us use [a Viem wallet](https://viem.sh/docs/clients/wallet) as [an Ethers signer](https://docs.ethers.org/v6/api/providers/#Signer).

          ```js file=<rootDir>/public/tutorials/attest.mjs#L65-L76 hash=b2979dabbf38960d5a8ad78a89b8b366
          ```

          Register the [EAS Schema](https://docs.attest.org/docs/tutorials/create-a-schema) if necessary.
          This schema ties Ethereum addresses to names.

          ```js file=<rootDir>/public/tutorials/attest.mjs#L78-L91 hash=0cc7174d12f3c31109aaa9e6d5b38cb6
          ```

          [Attest](https://docs.attest.org/docs/tutorials/make-an-attestation) that the name for Ethereum address `0x0123456789012345678901234567890123456789` is `Bill Hamm`.

          ```js file=<rootDir>/public/tutorials/attest.mjs#L93-L95 hash=0897bec3f88600ffc2c52db3dd4d124e
          ```

          This is the recommended way to execute the attestation transaction, which provides you with the attestation's UID.
          However, for our purpose we need the transaction receipt, which you do not get.
          We can either use this and search for the log entry or just use the EAS SDK to create the transaction and send it ourselves.
          Here we use the second solution.

          ```js file=<rootDir>/public/tutorials/attest.mjs#L97-L99 hash=fd5549e8b39af5b5652b889ca2a8cc05
          ```

          Here we send the attestation transaction created by the EAS SDK ourselves (using viem's [`sendRawTransaction`](https://viem.sh/docs/actions/wallet/sendRawTransaction)), so we'll have the transaction hash.
        </details>

  3.  Run the attestation program.

      ```sh
      node attest.mjs
      ```

  4.  The program output includes an `export ATTEST_TXN` line.
      Run it.
      The value here is for a fresh Supersim install.

      ```sh
      export ATTEST_TXN=0x607d1259ac309edb8c8b125c994c979178d1ce02765e419dcbdeb7f01244f270
      ```

  ### Verify the attestation on another chain (offchain code)

  The next step is to call `CrossL2Inbox.verifyMessage`.
  For testing purposes, we'll start by calling it offchain.

  1.  Create a file, `verify-attestation.mjs`.

      ```js file=<rootDir>/public/tutorials/verify-attestation.mjs hash=405d9493c3bf15f85aa9c24a936cf7a4 
      ```

      <details>
        <summary>Explanation</summary>

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L36-L45 hash=2e0e75ab322c05fb2eb8177978f47c55 
        ```

        To create the [executing message](/interop/message-passing#executing-message), we need several fields that appear in the log entry we are verifying. 
        This is how we obtain the relevant log entry.

        The first topic in a log entry emitted by Solidity is the event type. 
        [This event type](https://www.4byte.directory/event-signatures/?bytes_signature=0x8bf46bf4cfd674fa735a3d63ec1c9ad4153f033c290341f3a588b75685141b35) is emitted when an attestation is created.
        Of course, we only care about attestations created in the official attestations contract.

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L47 hash=2d9c5e52695aa90f1f0f9a5769f98814
        ```

        Part of testing a system is ensuring that it does not accept invalid input.
        You can uncomment this line to see that the verification fails with an incorrect log entry.

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L49-L51 hash=fbfb20fa0614cb9fb52ec678df6fffa9 
        ```

        [Build the executing message](https://github.com/ethereum-optimism/ecosystem/blob/main/packages/viem/docs/actions/interop/functions/buildExecutingMessage.md).

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L61-L74 hash=5c410cd233b0e4e68f33170de7da3b7f 
        ```

        Call [`CrossL2Inbox.validateMessage`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/CrossL2Inbox.sol#L68-L82).
        For some invalid inputs this function reverts, which means that the log entry requested is not validated.

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L76-L84 hash=2476aec8e2b27708ce812797e9e5dfe7 
        ```

        Wait for the transaction receipt for the executing message. 
        Note the timeout, it is necessary because if the executing message is valid, but the log entry has not been seen yet the sequencer does not put the transaction with the message into a block.

        ```js file=<rootDir>/public/tutorials/verify-attestation.mjs#L86-L91 hash=e870ee89daa5f2a31b0adc6a97f670a9 
        ```

        Look for the log entry from `CrossL2Inbox`.
        To ensure this is the correct log entry, we look at the [message type](https://www.4byte.directory/event-signatures/?bytes_signature=0x5c37832d2e8d10e346e55ad62071a6a2f9fa5130614ef2ec6617555c6f467ba7) and check that the ID is the correct one.

      </details>

  2.  Execute this program.

      ```sh
      node verify-attestation.mjs
      ```

  ### Onchain verifications

  The code in the above example is not very useful, because it is running offchain.
  Offchain code can talk to any chain it wants, so it can verify the attestation directly on the chain where it originated.

  The real value of interop is when you have onchain code from one chain verify information from another chain.
  This is what we'll build now.

  The access list of the transaction has to be calculated offchain, so we might as well just use the same `interop.buildExecutingMessage` function and just parse the `relayParam.payload` value to see what exactly we are validating.

  | Bytes | Meaning | Sample value |
  | - | - | - |
  | 0-31 | [Event signature](https://www.4byte.directory/event-signatures/?bytes_signature=8bf46bf4cfd674fa735a3d63ec1c9ad4153f033c290341f3a588b75685141b35) | 0x8bf46bf4cfd674fa735a3d63ec1c9ad4153f033c290341f3a588b75685141b35 
  | 32-63 | Emitting address (EAS contract) | 0x0000000000000000000000004200000000000000000000000000000000000021 
  | 64-95 | Block number| 0x0000000000000000000000000000000000000000000000000000000000002294 
  | 96-127 | Log index in the block | 0x0000000000000000000000000000000000000000000000000000000000000000 
  | 128-159 | Timestamp | 0x00000000000000000000000000000000000000000000000000000000682752ee 
  | 160-191 | Source chain ID | 0x0000000000000000000000000000000000000000000000000000000000000385 
  | 192-223 | Hash of the log entry | 0x41083d67fc7e4a91096348578fa4d22a95ebdbd795fdda8665d42e960240830a 

  The hash of the log entry is sufficient to verify that it has been emitted, but we want to know what exactly is being attested to, so we need the data that created it.
  That data is in `attestLogEntry`.

  | Data | Meaning | Sample value |
  | - | - | - |
  | topics[0] | [Event signature](https://www.4byte.directory/event-signatures/?bytes_signature=8bf46bf4cfd674fa735a3d63ec1c9ad4153f033c290341f3a588b75685141b35) | 0x8bf46bf4cfd674fa735a3d63ec1c9ad4153f033c290341f3a588b75685141b35 
  | topics[1] | Attestation recipient | 0x0000000000000000000000000123456789012345678901234567890123456789
  | topics[2] | Attestation source | 0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266
  | topics[3] | Attestation schema | 0x234dee4d3e6a625b4121e2042d6267058755e53a2ecc55555da51a1e6f06cc58 

  1.  Create a new Foundry project.

      ```sh
      mkdir ../onchain
      cd ../onchain
      forge init
      ```

  To 

</Steps>

## Next steps

*   Read the [Superchain Interop Explainer](/interop/explainer#faqs) or check out this [Superchain interop design video walk-thru](https://www.youtube.com/watch?v=FKc5RgjtGes).
*   Use [Supersim](/app-developers/tools/supersim), a local dev environment that simulates Superchain interop for testing applications against a local version of the Superchain.
*   Find a cool dapp that only works on a single blockchain and extend it to the entire interop cluster, at least for reading information.
