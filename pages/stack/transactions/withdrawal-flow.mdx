---
title: Withdrawal flow
description: Learn the withdrawal flow process for transactions sent from L2 to L1.
lang: en-US
content_type: guide
topic: withdrawal-flow
personas:
  - protocol-developer
  - chain-operator
  - app-developer
categories:
  - protocol
  - withdrawals
  - cross-domain-messaging
  - l2-to-l1
  - transaction-flow
  - optimism-portal
  - message-proving
  - message-finalization
is_imported_content: 'false'
---

import { Callout } from 'nextra/components'

# Withdrawal flow

In Optimism terminology, a *withdrawal* is a transaction sent from L2 (OP Mainnet, OP Sepolia etc.) to L1 (Ethereum mainnet, Sepolia, etc.).

Withdrawals require the user to submit three transactions:

1.  **Withdrawal initiating transaction**, which the user submits on L2.
2.  **Withdrawal proving transaction**, which the user submits on L1 to prove that the withdrawal is legitimate (based on a Merkle-Patricia trie root that commits to the state of the `L2ToL1MessagePasser`'s storage on L2)
3.  **Withdrawal finalizing transaction**, which the user submits on L1 after the fault challenge period has passed, to actually run the transaction on L1.

<Callout type="info">
  You can see an example of how to do this [in the bridging tutorials](/app-developers/tutorials/bridging/cross-dom-bridge-erc20).
</Callout>

## Withdrawal flow overview

The complete withdrawal process using viem has the following steps:

1.  Initiate the withdrawal transaction on L2
2.  Wait for the L2 output to be proposed (typically takes up to one hour)
3.  Prove the withdrawal transaction on L1
4.  Wait for the fault challenge period to pass (7 days on mainnet)
5.  Finalize the withdrawal transaction on L1

## Setting up the viem clients

Before working with withdrawals, you need to set up viem clients for both L1 and L2 chains with the appropriate extensions:

```javascript
// Import Viem modules
import { createPublicClient, createWalletClient, http } from 'viem'
import { mainnet, optimism } from 'viem/chains'
import { 
  publicActionsL1, 
  walletActionsL1, 
  publicActionsL2, 
  walletActionsL2 
} from 'viem/op-stack'

// Set up L1 clients (Ethereum)
const publicClientL1 = createPublicClient({
  chain: mainnet,
  transport: http()
}).extend(publicActionsL1())

const walletClientL1 = createWalletClient({
  account,
  chain: mainnet,
  transport: http()
}).extend(walletActionsL1())

// Set up L2 clients (Optimism)
const publicClientL2 = createPublicClient({
  chain: optimism,
  transport: http()
}).extend(publicActionsL2())

const walletClientL2 = createWalletClient({
  account,
  chain: optimism,
  transport: http()
}).extend(walletActionsL2())
```

## Withdrawal initiating transaction

The first step is to initiate a withdrawal on L2 by using the `buildInitiateWithdrawal` and `initiateWithdrawal` functions:

```javascript
// 1. Build parameters to initiate the withdrawal transaction
const args = await publicClientL1.buildInitiateWithdrawal({
  to: account.address,
  value: parseEther('1') // Amount to withdraw
})

// 2. Execute the initiate withdrawal transaction on L2
const hash = await walletClientL2.initiateWithdrawal(args)

// 3. Wait for the transaction receipt
const receipt = await publicClientL2.waitForTransactionReceipt({ hash })
```

Behind the scenes, this process triggers the following:

1.  When you call `initiateWithdrawal`, the transaction interacts with the [`L2ToL1MessagePasser`](https://github.com/ethereum-optimism/optimism/blob/1a8fe18c4989bfd0852a8873f30422542ad4f44d/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol#L19) contract on L2.
2.  The transaction calculates a hash of the withdrawal fields and marks it as a sent message in the contract's storage.
3.  A [`MessagePassed`](https://github.com/ethereum-optimism/optimism/blob/1a8fe18c4989bfd0852a8873f30422542ad4f44d/packages/contracts-bedrock/src/L2/L2ToL1MessagePasser.sol#L40) event is emitted with the withdrawal details and hash.
4.  When `op-proposer` proposes a new output, it includes the output root which commits to the state of the `L2ToL1MessagePasser` contract's storage, allowing your withdrawal to be proven on L1.

The raw withdrawal fields included in this process are:

*   `nonce` - A single-use value to prevent identical withdrawals from hashing to the same value
*   `sender` - The L2 address that initiated the transfer
*   `target` - The L1 target address
*   `value` - The amount of WEI transferred
*   `gasLimit` - Gas limit for the transaction execution on L1
*   `data` - The calldata for the withdrawal transaction

## Withdrawal proving transaction

Once an output root that includes your withdrawal is published to L1, you need to prove that the withdrawal is legitimate:

```javascript
// 1. Wait until the withdrawal is ready to prove
const { output, withdrawal } = await publicClientL1.waitToProve({
  receipt,
  targetChain: walletClientL2.chain
})

// 2. Build parameters to prove the withdrawal
const proveArgs = await publicClientL2.buildProveWithdrawal({
  output,
  withdrawal
})

// 3. Prove the withdrawal on L1
const proveHash = await walletClientL1.proveWithdrawal(proveArgs)

// 4. Wait for the prove transaction to be processed
const proveReceipt = await publicClientL1.waitForTransactionReceipt({
  hash: proveHash
})
```

The proving process works as follows:

1.  The `waitToProve` function waits until the L2 output containing your withdrawal has been proposed on L1.
2.  The `buildProveWithdrawal` function prepares the necessary parameters for proving, including the withdrawal details and the output proof.
3.  The `proveWithdrawal` function calls `OptimismPortal.proveWithdrawalTransaction()` on L1.
4.  The portal contract verifies that the withdrawal hash exists in `L2ToL1MessagePasser.sentMessages` on L2, and that this proof hasn't been submitted before.
5.  If verification passes, the contract writes the output root, timestamp, and L2 output index to `provenWithdrawals` and emits an event.

You can also check a withdrawal's status at any time using:

```javascript
const status = await publicClientL1.getWithdrawalStatus({
  receipt,
  targetChain: walletClientL2.chain
})

if (status === 'ready-to-prove') {
  // Ready to prove the withdrawal
}
```

## Withdrawal finalizing transaction

After the fault challenge period passes (7 days on mainnet), you can finalize and execute the withdrawal on L1:

```javascript
// 1. Wait until the withdrawal is ready to finalize
await publicClientL1.waitToFinalize({
  targetChain: walletClientL2.chain,
  withdrawalHash: withdrawal.withdrawalHash
})

// 2. Finalize the withdrawal
const finalizeHash = await walletClientL1.finalizeWithdrawal({
  targetChain: walletClientL2.chain,
  withdrawal
})

// 3. Wait for the finalization transaction to be processed
const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
  hash: finalizeHash
})
```

The finalization process:

1.  `waitToFinalize` waits until the fault challenge period has passed.
2.  `finalizeWithdrawal` calls `OptimismPortal.finalizeWithdrawalTransaction()` on L1.
3.  The portal contract runs several checks:
    *   Verifies the proof has been submitted
    *   Confirms the challenge period has passed
    *   Verifies the proof applies to the current output root
    *   Checks that the transaction hasn't been finalized before
4.  If all checks pass, the contract:
    *   Marks the withdrawal as finalized in `finalizedWithdrawals`
    *   Executes the actual withdrawal transaction (calls the target contract with the calldata in `data`)
    *   Emits a `WithdrawalFinalized` event

You can track the time until finalization using:

```javascript
const { seconds } = await publicClientL1.getTimeToFinalize({
  withdrawalHash: withdrawal.withdrawalHash,
  targetChain: walletClientL2.chain
})
console.log(`Time until finalization: ${seconds} seconds`)
```

## Complete example

Here's a complete example of the withdrawal flow:

```javascript
import { parseEther } from 'viem'
import { getWithdrawals } from 'viem/op-stack'
import {
  account,
  publicClientL1,
  walletClientL1,
  publicClientL2,
  walletClientL2
} from './config'

// Build parameters to initiate the withdrawal transaction
const args = await publicClientL1.buildInitiateWithdrawal({
  to: account.address,
  value: parseEther('1')
})

// Execute the initiate withdrawal transaction on the L2
const hash = await walletClientL2.initiateWithdrawal(args)

// Wait for the initiate withdrawal transaction receipt
const receipt = await publicClientL2.waitForTransactionReceipt({ hash })

// Wait until the withdrawal is ready to prove
const { output, withdrawal } = await publicClientL1.waitToProve({
  receipt,
  targetChain: walletClientL2.chain
})

// Build parameters to prove the withdrawal
const proveArgs = await publicClientL2.buildProveWithdrawal({
  output,
  withdrawal
})

// Prove the withdrawal on the L1
const proveHash = await walletClientL1.proveWithdrawal(proveArgs)

// Wait until the prove withdrawal is processed
const proveReceipt = await publicClientL1.waitForTransactionReceipt({
  hash: proveHash
})

// Wait until the withdrawal is ready to finalize
await publicClientL1.waitToFinalize({
  targetChain: walletClientL2.chain,
  withdrawalHash: withdrawal.withdrawalHash
})

// Finalize the withdrawal
const finalizeHash = await walletClientL1.finalizeWithdrawal({
  targetChain: walletClientL2.chain,
  withdrawal
})

// Wait until the withdrawal is finalized
const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
  hash: finalizeHash
})

console.log('Withdrawal completed successfully!')
```

## Expected internal reverts in withdrawal transactions

During the withdrawal process, users may observe internal reverts when viewing the transaction on **Etherscan**. This is a common point of confusion but is expected behavior.

These internal reverts often show up in yellow on the Etherscan UI and may cause concern that something went wrong with the transaction. However, these reverts occur due to the non-standard proxy used in Optimism, specifically the **Chugsplash Proxy**. The Chugsplash Proxy sometimes triggers internal calls that revert as part of the designed flow of the withdrawal process.

### Why do these reverts happen?

The Chugsplash Proxy operates differently than standard proxies. During a withdrawal transaction, it may trigger internal contract calls that result in reverts, but these reverts do not indicate that the withdrawal has failed. Instead, they are part of the internal logic of the system and are expected in certain scenarios.
